/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_init.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: afogonca <afogonca@student.42porto.com>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/25 13:40:02 by afogonca          #+#    #+#             */
/*   Updated: 2025/05/01 16:27:11 by afogonca         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../incs/cub3d.h"

double ft_get_time_in_ms()
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return (tv.tv_sec * 1000.0) + (tv.tv_usec / 1000.0);
}

char	**ft_cp2bm(char **map, int height, int width, int scale)
{
	int new_height = height * scale;
	int new_width = width * scale;

	char **upscaled = malloc(sizeof(char *) * (new_height + 1));
	if (!upscaled)
		return NULL;

	for (int y = 0; y < height; y++) {
		for (int sy = 0; sy < scale; sy++) {
			// Allocate each new row
			int new_row_index = y * scale + sy;
			upscaled[new_row_index] = malloc(new_width + 1);
			if (!upscaled[new_row_index]) {
				// Free previous rows on failure
				for (int k = 0; k < new_row_index; k++)
					free(upscaled[k]);
				free(upscaled);
				return NULL;
			}

			for (int x = 0; x < width; x++) {
				for (int sx = 0; sx < scale; sx++) {
					if ((map[y][x] == 'H' && (sx <= 0.3 * scale || sx >= 0.6 * scale)))
						// || (map[y][x] == 'H' && (y * scale >= new_row_index + 3
						// 	|| y * scale <= new_row_index - 3)))
						{
							upscaled[new_row_index][x * scale + sx] = '0';
						}
					else
						upscaled[new_row_index][x * scale + sx] = map[y][x];
				}
			}
			upscaled[new_row_index][new_width] = '\0'; // null-terminate each row
		}
	}
	upscaled[new_height] = NULL; // null-terminate the array
	return upscaled;
}

void	ft_load_911(t_data *data)
{
	char	*file;
	char	*tmp;
	int		file_nbr;

	file_nbr = 1;
	file = ft_itoa(file_nbr);
	while (ft_strlen(file) < 5)
	{
		file = ft_strjoin("0", file);
	}
	printf("%s\n", file);

	// data->_911 = malloc(sizeof(t_img_list));
	exit(1);	
	(void) data;
}

t_data	*ft_data_init(void)
{
	t_data *data;

	data = malloc(sizeof(t_data));
	ft_data_set_def(data);
	data->ray = malloc(sizeof(t_ray));
	if (!data->ray)
		ft_free(-1, data);
	data->map = malloc(sizeof(char *) * 10);
	if (!data->map)
		ft_free(-1, data);
	data->map[0] = ft_strdup("1111111111");
	data->map[1] = ft_strdup("1010100001");
	data->map[2] = ft_strdup("1000001101");
	data->map[3] = ft_strdup("1000001101");
	data->map[4] = ft_strdup("1000000001");
	data->map[5] = ft_strdup("1001001001");
	data->map[6] = ft_strdup("1001001001");
	data->map[7] = ft_strdup("100000H001");
	data->map[8] = ft_strdup("1111111111");
	data->map[9] = NULL; //should put malloc protection here but gonna leave it because its gonna be joanas part
	data->map_height = 9;
	data->map_width = ft_strlen(data->map[0]);
	data->scale = 5;
	data->bigmap = ft_cp2bm(data->map, data->map_height, data->map_width, data->scale);
	data->map = data->bigmap;
	data->mov = malloc(sizeof(t_mov));
	if (!data->mov)
		ft_free(-1, data);
	ft_mov_set_def(data->mov);

	data->door = malloc(sizeof(t_door *) * 2);
	data->door[0] = malloc(sizeof(t_door));
	data->door[1] = NULL;
	data->door[0]->x_pos = 7;
	data->door[0]->y_pos = 6;
	data->door[0]->pos = 0.5;
	data->door[0]->open = 0;
	data->door[0]->last_open = 2;
	data->player1 = malloc(sizeof(t_player));
	if (!data->player1)
		ft_free(-1, data);
	data->player1->x_pos = 4.5 * data->scale;
	data->player1->y_pos = 3.5 * data->scale;
	data->player1->angle = 90;
	data->player1->y_look = cos(data->player1->angle * M_PI / 180.0);
	data->player1->x_look = sin(data->player1->angle * M_PI / 180.0);
	data->time_frame = ft_get_time_in_ms() + 17;
	data->bigmap[(int) (data->player1->x_pos)]
		[(int) (data->player1->y_pos)] = 'P';

	data->enemy_arr = malloc(sizeof(t_enemy *) * 10);
	data->enemy_arr[0] = NULL;
	data->enemy_arr[1] = NULL;
	data->enemy_arr[2] = NULL;
	data->enemy_arr[3] = NULL;
	data->enemy_arr[4] = NULL;
	data->enemy_arr[5] = NULL;
	data->enemy_arr[6] = NULL;
	data->enemy_arr[7] = NULL;
	data->enemy_arr[8] = NULL;
	data->enemy_arr[9] = NULL;

	ft_win_start(data);
	data->enemy = malloc(sizeof(t_enemy));
	data->enemy->data = malloc(sizeof(t_player));
	if (!data->enemy->data)
		ft_free(-1, data);
	data->enemy->data->x_pos = 2.5 * data->scale;
	data->enemy->data->y_pos = 3.5 * data->scale;
	data->bigmap[(int) (data->enemy->data->x_pos)]
		[(int) (data->enemy->data->y_pos)] = 'A';
	data->enemy->data->angle = 100;
	data->enemy->map = 'A';
	data->enemy->ray = malloc(sizeof(t_ray));
	data->enemy->rdata = data;
	data->enemy->tex_iddle = malloc(sizeof(t_tex_iddle));
	data->enemy->tex_iddle->sprite1 = malloc(sizeof(t_img));
	if (!data->enemy->tex_iddle->sprite1)
		ft_free(-1, data);
	ft_start_tex(data, data->enemy->tex_iddle->sprite1, "idle1.xpm");

	data->enemy->tex_iddle->sprite2 = malloc(sizeof(t_img));
	if (!data->enemy->tex_iddle->sprite2)
		ft_free(-1, data);
	ft_start_tex(data, data->enemy->tex_iddle->sprite2, "idle2.xpm");

	data->enemy->tex_iddle->sprite3 = malloc(sizeof(t_img));
	if (!data->enemy->tex_iddle->sprite3)
		ft_free(-1, data);
	ft_start_tex(data, data->enemy->tex_iddle->sprite3, "idle3.xpm");

	data->enemy->tex_iddle->sprite4 = malloc(sizeof(t_img));
	if (!data->enemy->tex_iddle->sprite4)
		ft_free(-1, data);
	ft_start_tex(data, data->enemy->tex_iddle->sprite4, "idle4.xpm");
	data->enemy->tex = data->enemy->tex_iddle->sprite4;

	data->enemy->tex_iddle->sprite5 = malloc(sizeof(t_img));
	if (!data->enemy->tex_iddle->sprite5)
		ft_free(-1, data);
	ft_start_tex(data, data->enemy->tex_iddle->sprite5, "idle5.xpm");

	data->enemy->tex_iddle->sprite6 = malloc(sizeof(t_img));
	if (!data->enemy->tex_iddle->sprite6)
		ft_free(-1, data);
	ft_start_tex(data, data->enemy->tex_iddle->sprite6, "idle6.xpm");
	data->enemy->data->y_look = cos(data->enemy->data->angle * M_PI / 180.0);
	data->enemy->data->x_look = sin(data->enemy->data->angle * M_PI / 180.0);
	data->enemy->next_frame = 0;
	data->enemy->frame = 0;

	data->enemy_arr[0] = data->enemy;
	// data->enemy_arr[1] = malloc(sizeof(t_enemy));
	// if (!data->enemy_arr[1])
	// 	ft_free(-1, data);
	// data->enemy_arr[1]->map = 'E';
	// data->enemy_arr[1]->next = NULL;
	// data->enemy_arr[1]->data = malloc(sizeof(t_player));
	// if (!data->enemy->data)
	// 	ft_free(-1, data);
	// data->enemy_arr[1]->data->x_pos = 1.5;
	// data->enemy_arr[1]->data->y_pos = 1.5;
	// data->enemy_arr[1]->data->angle = 100;
	// data->enemy_arr[1]->map = 'B';
	// data->enemy_arr[1]->rdata = data;
	// data->enemy_arr[1]->ray = malloc(sizeof(t_ray));
	// data->enemy_arr[1]->tex_iddle = data->enemy_arr[0]->tex_iddle;
	// data->enemy_arr[1]->tex = data->enemy_arr[1]->tex_iddle->sprite1;
	// data->enemy_arr[1]->data->y_look = cos(data->enemy_arr[1]->data->angle * M_PI / 180.0);
	// data->enemy_arr[1]->data->x_look = sin(data->enemy_arr[1]->data->angle * M_PI / 180.0);

	data->tex_north = malloc(sizeof(t_img));
	if (!data->tex_north)
		ft_free(-1, data);
	ft_start_tex(data, data->tex_north, "north.xpm");

	data->tex_south = malloc(sizeof(t_img));
	if (!data->tex_south)
		ft_free(-1, data);
	ft_start_tex(data, data->tex_south, "south.xpm");

	data->tex_east = malloc(sizeof(t_img));
	if (!data->tex_east)
		ft_free(-1, data);
	ft_start_tex(data, data->tex_east, "east.xpm");

	data->tex_west = malloc(sizeof(t_img));
	if (!data->tex_west)
		ft_free(-1, data);
	ft_start_tex(data, data->tex_west, "west.xpm");

	data->nbr_threads = 16;
	data->tdata = malloc(sizeof(t_thread_data) * data->nbr_threads + 1);
	data->thread = malloc(sizeof(pthread_t) * data->nbr_threads + 1);
	int	i = -1;
	while (++i < data->nbr_threads)
	{
		data->tdata[i].ray = malloc(sizeof(t_ray));
    	data->tdata[i].data = data;
    	data->tdata[i].start_x = i * data->width / data->nbr_threads;
    	data->tdata[i].end_x = (i + 1) * data->width / data->nbr_threads;
	}
	data->player1->angle_y = 0;
	data->nbrs = malloc(sizeof(t_tex_nbrs));

	data->nbrs->nbr_0 = malloc(sizeof(t_img));
	if (!data->nbrs->nbr_0)
		ft_free(-1, data);
	ft_start_tex(data, data->nbrs->nbr_0, "0.xpm");

	data->nbrs->nbr_1 = malloc(sizeof(t_img));
	if (!data->nbrs->nbr_1)
		ft_free(-1, data);
	ft_start_tex(data, data->nbrs->nbr_1, "1.xpm");

	data->nbrs->nbr_2 = malloc(sizeof(t_img));
	if (!data->nbrs->nbr_2)
		ft_free(-1, data);
	ft_start_tex(data, data->nbrs->nbr_2, "2.xpm");

	data->nbrs->nbr_3 = malloc(sizeof(t_img));
	if (!data->nbrs->nbr_3)
		ft_free(-1, data);
	ft_start_tex(data, data->nbrs->nbr_3, "3.xpm");

	data->nbrs->nbr_4 = malloc(sizeof(t_img));
	if (!data->nbrs->nbr_4)
		ft_free(-1, data);
	ft_start_tex(data, data->nbrs->nbr_4, "4.xpm");

	data->nbrs->nbr_5 = malloc(sizeof(t_img));
	if (!data->nbrs->nbr_5)
		ft_free(-1, data);
	ft_start_tex(data, data->nbrs->nbr_5, "5.xpm");

	data->nbrs->nbr_6 = malloc(sizeof(t_img));
	if (!data->nbrs->nbr_6)
		ft_free(-1, data);
	ft_start_tex(data, data->nbrs->nbr_6, "6.xpm");

	data->nbrs->nbr_7 = malloc(sizeof(t_img));
	if (!data->nbrs->nbr_7)
		ft_free(-1, data);
	ft_start_tex(data, data->nbrs->nbr_7, "7.xpm");

	data->nbrs->nbr_8 = malloc(sizeof(t_img));
	if (!data->nbrs->nbr_8)
		ft_free(-1, data);
	ft_start_tex(data, data->nbrs->nbr_8, "8.xpm");

	data->nbrs->nbr_9 = malloc(sizeof(t_img));
	if (!data->nbrs->nbr_9)
		ft_free(-1, data);
	ft_start_tex(data, data->nbrs->nbr_9, "9.xpm");

	data->tex_pause = malloc(sizeof(t_img));
	if (!data->tex_pause)
		ft_free(-1, data);
	ft_start_tex(data, data->tex_pause, "menu.xpm");

	data->tex_pl = malloc(sizeof(t_img));
	if (!data->tex_pl)
		ft_free(-1, data);
	ft_start_tex(data, data->tex_pl, "portal_blue.xpm");
	data->fps_time = ft_get_time_in_ms();
	data->old_frame = ft_get_time_in_ms() + 5;
	data->total_fps = 0;
	data->fps_count = 0;
	ft_load_911(data);
	return (data);
}

void	ft_start_tex(t_data *data, t_img *img, char *file)
{
	img->img = NULL;
	img->img = mlx_xpm_file_to_image(data->mlx, file, &img->x, &img->y);
	if (!img->img)
		ft_free(-1, data);
	img->addr = (int *)mlx_get_data_addr(img->img, &img->pixel_bits, &img->size_line, &img->endian);
}

void	ft_mov_set_def(t_mov *mov)
{
	mov->mov_f = false;
	mov->mov_b = false;
	mov->mov_l = false;
	mov->mov_r = false;
	mov->mov = false;
	mov->look = true;
	mov->exit = false;
	mov->exit_main = false;
	mov->lookl = false;
	mov->lookr = false;
	mov->lookml = 0;
	mov->lookmr = 0;
	mov->sound = 0;
	mov->jump = 0;
	mov->shoot = 0;
	mov->pause = false;
	mov->open = false;
	mov->time_sound = ft_get_time_in_ms();
}

void	ft_win_start(t_data *data)
{
	data->mlx = mlx_init();
	if (!data->mlx)
		ft_free(-1, data);
	data->win = mlx_new_window(data->mlx, data->width, data->height, "cub3d");
	if (!data->win)
		ft_free(-1, data);

	data->img_player = malloc(sizeof(t_img));
	if (!data->img_player)
		ft_free(-1, data);
	data->img_player->img = NULL;
	data->img_player->img = mlx_new_image(data->mlx, data->width, data->height);
	if (!data->img_player->img)
		ft_free(-1, data);
	data->img_player->addr = (int *)mlx_get_data_addr(data->img_player->img, &data->img_player->pixel_bits,
			&data->img_player->size_line, &data->img_player->endian);
	data->img = data->img_player;

	data->img_portal = malloc(sizeof(t_img));
	if (!data->img_portal)
		ft_free(-1, data);
	data->img_portal->img = NULL;
	data->img_portal->img = mlx_new_image(data->mlx, data->width, data->height);
	if (!data->img_portal->img)
		ft_free(-1, data);
	data->img_portal->addr = (int *)mlx_get_data_addr(data->img_portal->img, &data->img_portal->pixel_bits,
			&data->img_portal->size_line, &data->img_portal->endian);
	data->img_portal->x = data->width;
	data->img_portal->y = data->height;

	data->img_pause = malloc(sizeof(t_img));
	if (!data->img_pause)
		ft_free(-1, data);
	data->img_pause->img = NULL;
	data->img_pause->img = mlx_new_image(data->mlx, data->width, data->height);
	if (!data->img_pause->img)
		ft_free(-1, data);
	data->img_pause->addr = (int *)mlx_get_data_addr(data->img_pause->img,
			&data->img_pause->pixel_bits, &data->img_pause->size_line, &data->img_pause->endian);
	data->zbuffer = malloc(sizeof(double) * data->width);
}

void	ft_data_set_def(t_data *data)
{
	data->img = NULL;
	data->texture_wall = NULL;
	data->tex_north = NULL;
	data->tex_south = NULL;
	data->tex_east = NULL;
	data->tex_west = NULL;
	data->mlx = NULL;
	data->win = NULL;
	data->player = NULL;
	data->ray = NULL;
	data->mov = NULL;
	data->map = NULL;
	data->hex_ceiling = 0;
	data->hex_floor = 0;
	data->time_frame = 0;
	data->old_frame = 0;
	data->hex_ceiling = 0x0000FF; // change both for 0x000000 after parsing is done
	data->hex_floor = 0xFF0000;
	data->width = 1280;
	data->height = 720;
	data->frame_time = 0;
	data->see_portal = false;
}


